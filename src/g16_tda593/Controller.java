// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package g16_tda593;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.Timer;

import project.AbstractRobotSimulator;
import project.AbstractSimulatorMonitor;
import project.LocationController;
import project.Point;
import g16_tda593.RobotAvatar;
import simbad.sim.EnvironmentDescription;
import g16_tda593.Environment;
import g16_tda593.Mission;
import g16_tda593.RewardSystem;
import g16_tda593.View;

/************************************************************/
/**
 * 
 */
public class Controller extends AbstractSimulatorMonitor<RobotAvatar> {
	/**
	 * 
	 */
	private List<View> views;
	
	private List<Area> areas;
	private Timer rewardTimer;
	private Timer strategyTimer;
	/**
	 * 
	 */
	//private List<Mission> missions;
	/**
	 * 
	 */
	private Set<RobotAvatar> robots;
	/**
	 * 
	 */
	private List<Gatekeeper> gatekeepers;
	/**
	 * 
	 */
	private Environment environment;
	/**
	 * 
	 */
	private RewardSystem rs;
	
	public Controller(Set<RobotAvatar> robots, EnvironmentDescription e, Environment environment) {
		super(robots, e);
		views = new ArrayList<View>();
		this.robots = robots;
		gatekeepers = new ArrayList<Gatekeeper>();
		this.environment = environment;
		rs = new RewardSystem(environment.getAreas(), robots);
		rewardTimer = new Timer();
		init();
		this.strategyTimer = new Timer();
		areas = new ArrayList<>();
	}
	
	private void init() {
		/*20000 = 20 SECONDS, CHANGE THIS IF YOU WANT A DIFFERENT UPDATE RATE OF REWARDPOINTS*/
		rewardTimer.scheduleAtFixedRate(rs, 20000, 20000);
	}
	
	public double distance(RobotAvatar r, Gatekeeper gk) {
		double distance = Math.hypot(r.getPosition().getX() - gk.getCenter().getX(),
				r.getPosition().getZ() - gk.getCenter().getZ());
		return distance;
	}

	@Override
	public void update(RobotAvatar robot) {
		if(robot.getStrategy().isLocked() && System.currentTimeMillis() < robot.getStrategy().getCurrentTime() + 2000) {
			robot.setDestination(robot.getPosition());
		} else {
			if(!robot.getMission().getPoints().isEmpty()) {
				if(robot.isAtPosition(robot.getMission().getPoints().peek())) {
					if(!robot.getStrategy().isLocked()) {							
						robot.getStrategy().setCurrentTime(System.currentTimeMillis());
						robot.getStrategy().setLocked(true);
					} else if(robot.getStrategy().isLocked() && System.currentTimeMillis() < robot.getStrategy().getCurrentTime() + 2000) {
						robot.getStrategy().setLocked(false);
						robot.getMission().getPoints().pop();
						executeMission(robot);
					}
					else {
						robot.getMission().getPoints().pop();
						executeMission(robot);
					}
				} else {
					robot.getStrategy().setLocked(false);
					executeMission(robot);
				}
			}
			
			for(Gatekeeper k : gatekeepers) {
				if(distance(robot, k) < k.getRadius()) {
					if(!k.tryAcquire(robot) && k.getOwner().getId() != robot.getId()){
						robot.setDestination(robot.getPosition());
					} else if(k.getOwner() == null) {
						k.setOwner(robot);
					} else if(k.getOwner().getId() != robot.getId()) {
						k.setOwner(robot);
					}
					
				} else if(k.getOwner() != null && robot.getId() == k.getOwner().getId()) {
					if(distance(robot, k) > k.getRadius()) {
						k.release(robot);
						k.setOwner(null);
					}
				}
			}
			
			for(Area a : areas) {
				if(a.containsRobot(robot) && a instanceof PhysicalArea) {
					if(robot.getCurrentArea() == null) {
						robot.setCurrentArea(a);
					} else if(robot.getCurrentArea().getId() != a.getId()) {
						robot.setCurrentArea(a);
						robot.getStrategy().setCurrentTime(System.currentTimeMillis());
						robot.getStrategy().setLocked(true);
						robot.setDestination(robot.getPosition());
					}
				}
			}
		}
	}
	
	public void addLocationController(Gatekeeper lc) {
		this.gatekeepers.add(lc);
	}
	
	public Set<RobotAvatar> getRobots() {
		return this.robots;
	}
	
	public void addRobot(RobotAvatar r) {
		robots.add(r);
	}
	
	public Environment getEnvironment() {
		return this.environment;
	}
	

	/**
	 * 
	 * @param robot 
	 */
	public void executeMission(RobotAvatar robot) {
		if(robot == null) {
			System.out.println("Robot is null");
			return;
		} else if(robot.getMission() == null || robot.getMission().getPoints().isEmpty()) {
			robot.setDestination(robot.getPosition());
			return;
		} else if(robot.getStrategy().isLocked()) {
			robot.setDestination(robot.getPosition());
			return;
		} else{
			Point currentPoint = (Point) robot.getMission().getPoints().peek();
			robot.setDestination(currentPoint);
		}
	}

	/**
	 * 
	 * @param view 
	 */
	public void registerView(View view) {
	}

	/**
	 * 
	 * @param m 
	 * @param r 
	 */
	public void addMissionToRobot(Mission m, RobotAvatar r) {
		r.setMission(m);
	}

	/**
	 * 
	 * @param r 
	 */
	public void removeMission(RobotAvatar r) {
		r.setMission(null);
	}

	/**
	 * 
	 */
	public void stopEverything() {
		for(AbstractRobotSimulator r : robots) {
			((RobotAvatar) r).setMission(null);
		}
	}
	
	public void addArea(Area a) {
		areas.add(a);
	}
};
